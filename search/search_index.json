{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ja - JSONL Algebra","text":"<p>ja is a lightweight command-line tool and Python library for performing relational algebra operations on JSONL (JSON Lines) data. It's designed to be a simple, dependency-free alternative for common data manipulation tasks, inspired by tools like <code>jq</code> and traditional SQL.</p>"},{"location":"#features","title":"Features","text":"<ul> <li> <p>Perform common relational algebra operations: select, project, join, union, intersection, difference, distinct, sort, product, and group by with aggregations.</p> </li> <li> <p><code>groupby</code>: A powerful feature that allows you to group data by one or more keys and perform various aggregations on the grouped data.</p> </li> <li>By default, includes <code>sum</code>, <code>avg</code>, <code>min</code>, <code>max</code>, <code>count</code>, <code>list</code> (collect all values), <code>first</code> (first value in group), <code>last</code> (last value in group) aggregations.</li> <li>Can be extended with custom aggregation functions. See \"Extending Group By Aggregations\" section.</li> <li>Works with JSONL files or piped data from stdin/stdout.</li> <li>Can be used as a CLI tool or as a Python library.</li> <li>No external dependencies.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>There are two main ways to install <code>ja</code>:</p>"},{"location":"#for-users-from-pypi","title":"For users (from PyPI):","text":"<p>You can install the package directly from PyPI (Python Package Index) using pip. We'll assume the package is published under the name <code>jsonl-algebra</code> (as <code>ja</code> is likely taken):</p> <pre><code>pip install jsonl-algebra\n</code></pre>"},{"location":"#for-developers-from-local-repository","title":"For developers (from local repository):**","text":"<p>If you have cloned this repository and want to install it for development or from local sources:</p> <pre><code>pip install .\n</code></pre> <p>To install in editable mode for development:</p> <pre><code>pip install -e .\n</code></pre>"},{"location":"#cli-usage","title":"CLI Usage","text":"<p>The <code>ja</code> command-line tool provides several subcommands for different operations.</p> <p>General Syntax: <code>ja &lt;command&gt; [options] [file(s)]</code></p> <p>If <code>file</code> is omitted for commands that expect a single input, <code>ja</code> reads from stdin.</p>"},{"location":"#examples","title":"Examples","text":"<ul> <li> <p>Select rows where 'amount' is greater than 100:</p> <p><code>bash cat data.jsonl | ja select 'amount &gt; 100'</code></p> <p><code>bash ja select 'amount &gt; 100' data.jsonl</code></p> </li> <li> <p>Project 'id' and 'name' columns:</p> <p><code>bash cat data.jsonl | ja project id,name</code></p> </li> <li> <p>Join two files on a common key:</p> <p><code>bash ja join users.jsonl orders.jsonl --on user_id=customer_id</code></p> </li> <li> <p>Group by 'category' and count items:</p> <p><code>bash cat products.jsonl | ja groupby category --agg count</code></p> </li> <li> <p>Group by 'category', count items, and list all product names:</p> <p><code>bash cat products.jsonl | ja groupby category --agg count --agg list:name\\</code></p> <p>This will produce output like: <code>{\"category\": \"electronics\", \"count\": 5, \"list_name\": [\"laptop\", \"mouse\", ...]}</code></p> </li> <li> <p>Group by 'user_id' and get the first action:</p> <p><code>bash cat user_actions.jsonl | ja groupby user_id --agg first:action</code></p> </li> <li> <p>Sort data by 'timestamp':</p> <p><code>bash cat logs.jsonl | ja sort timestamp</code></p> </li> </ul>"},{"location":"#available-commands","title":"Available Commands","text":"<ul> <li><code>select</code>: Filter rows based on a Python expression.</li> <li><code>project</code>: Select specific columns.</li> <li><code>join</code>: Join two relations on specified keys.</li> <li><code>rename</code>: Rename columns.</li> <li><code>union</code>: Combine two relations (all rows).</li> <li><code>difference</code>: Rows in the first relation but not the second.</li> <li><code>distinct</code>: Remove duplicate rows.</li> <li><code>intersection</code>: Rows common to both relations.</li> <li><code>sort</code> (maps to <code>sort_by</code>): Sort a relation by specified keys.</li> <li><code>product</code>: Cartesian product of two relations.</li> <li><code>groupby</code> (maps to <code>groupby_agg</code>): Group rows by a key and perform aggregations.</li> </ul> <p>Use <code>ja &lt;command&gt; --help</code> for more details on specific commands.</p>"},{"location":"#programmatic-api-usage","title":"Programmatic API Usage","text":"<p>You can also use <code>ja</code> as a Python library:</p> <pre><code>import ja\nfrom ja import Row, Relation # For type hinting if needed\n\n# Load data from JSONL files\n# users_data = ja.read_jsonl(\"users.jsonl\")\n# orders_data = ja.read_jsonl(\"orders.jsonl\")\n\n# Example data (replace with ja.read_jsonl for actual files)\nusers_data: Relation = [\n    {\"user_id\": 1, \"name\": \"Alice\", \"status\": \"active\", \"email\": \"alice@example.com\"},\n    {\"user_id\": 2, \"name\": \"Bob\", \"status\": \"inactive\", \"email\": \"bob@example.com\"},\n    {\"user_id\": 1, \"name\": \"Alice\", \"status\": \"active\", \"email\": \"alice@example.com\"} # Duplicate for distinct example\n]\norders_data: Relation = [\n    {\"order_id\": 101, \"customer_id\": 1, \"item\": \"Book\", \"quantity\": 1},\n    {\"order_id\": 102, \"customer_id\": 2, \"item\": \"Pen\", \"quantity\": 5},\n    {\"order_id\": 103, \"customer_id\": 1, \"item\": \"Notebook\", \"quantity\": 2},\n    {\"order_id\": 104, \"customer_id\": 1, \"item\": \"Book\", \"quantity\": 3}\n]\n\n\n# Example: Select active users\nactive_users = ja.select(users_data, lambda row: row.get(\"status\") == \"active\")\n# active_users will be:\n# [{'user_id': 1, 'name': 'Alice', 'status': 'active', 'email': 'alice@example.com'},\n#  {'user_id': 1, 'name': 'Alice', 'status': 'active', 'email': 'alice@example.com'}]\n\n# Example: Project name and email from distinct active users\ndistinct_active_users = ja.distinct(active_users)\nuser_info = ja.project(distinct_active_users, [\"name\", \"email\"])\n# user_info will be:\n# [{'name': 'Alice', 'email': 'alice@example.com'}]\n\n# Example: Join distinct active users with their orders\n# Ensure the join key 'user_id' is present in the projected active_users relation\nactive_users_with_id = ja.project(distinct_active_users, [\"user_id\", \"name\", \"email\"])\njoined_data = ja.join(active_users_with_id, orders_data, on=[(\"user_id\", \"customer_id\")])\n# joined_data will be:\n# [{'user_id': 1, 'name': 'Alice', 'email': 'alice@example.com', 'order_id': 101, 'item': 'Book', 'quantity': 1},\n#  {'user_id': 1, 'name': 'Alice', 'email': 'alice@example.com', 'order_id': 103, 'item': 'Notebook', 'quantity': 2},\n#  {'user_id': 1, 'name': 'Alice', 'email': 'alice@example.com', 'order_id': 104, 'item': 'Book', 'quantity': 3}]\n\n# Example: Group joined data by user and sum quantities, list items\ngrouped_orders = ja.groupby_agg(\n    joined_data,\n    group_by_key=\"user_id\",\n    aggregations=[\n        (\"sum\", \"quantity\"),\n        (\"list\", \"item\"),\n        (\"count\", \"\") # Count groups\n    ]\n)\n# grouped_orders might be (depending on Alice's orders):\n# [{'user_id': 1, 'sum_quantity': 6, 'list_item': ['Book', 'Notebook', 'Book'], 'count': 3}]\n\n\n# Print results (example)\nfor row in grouped_orders:\n    print(row)\n\n# Available functions mirror the CLI commands:\n# ja.select, ja.project, ja.join, ja.rename, ja.union,\n# ja.difference, ja.distinct, ja.intersection, ja.sort_by,\n# ja.product, ja.groupby_agg\n</code></pre>"},{"location":"#extending-group-by-aggregations","title":"Extending Group By Aggregations","text":"<p>By default, <code>ja</code> supports several built-in aggregation functions for the <code>groupby_agg</code> operation. These include: <code>count</code>, <code>sum</code>, <code>avg</code>, <code>min</code>, <code>max</code>, <code>list</code>, <code>first</code>, and <code>last</code>. Syntax for aggregations: <code>agg_name</code> (for count) or <code>agg_name:column_name</code> (e.g., <code>sum:price</code>, <code>list:product_id</code>).</p> <p>The <code>groupby_agg</code> functionality is designed to be extensible. The core logic resides in the <code>ja.groupby</code> module, which uses a dispatcher pattern.</p>"},{"location":"#define-an-aggregation-helper-function","title":"Define an aggregation helper function","text":"<p>This function will take the collected data for a group (typically a list of values, or a single value for aggregations like <code>first</code>/<code>last</code>) and return the aggregated result.</p> <p>For instance, if you want to add a custom aggregation function for calculating the median, you would define a function that takes a list of values and returns the median.</p> <pre><code>def _my_custom_median_agg(collected_values: list) -&gt; float | None:\n    numeric_vals = sorted([v for v in collected_values if isinstance(v, (int, float))])\n    if not numeric_vals:\n        return None\n    n = len(numeric_vals)\n    mid = n // 2\n    if n % 2 == 0:\n        return (numeric_vals[mid - 1] + numeric_vals[mid]) / 2\n    else:\n        return numeric_vals[mid]\n</code></pre> <p>Now, register it (if modifying <code>ja</code> directly or for illustration):</p> <pre><code># In ja/groupby.py\nAGGREGATION_DISPATCHER = {\n    # ...\n    \"median\": _my_custom_median_agg,\n}\n</code></pre> <p>For programmatic use with your own <code>ja</code> instance or a forked version, you could potentially expose a way to register custom aggregators or pass them directly if the API supported it.</p> <p>If your aggregation requires a specific way of collecting data during the first pass of <code>groupby_agg</code> (different from how <code>list</code>, <code>first</code>, or <code>last</code> collect data), you would need to modify the data collection logic in <code>ja.groupby.groupby_agg</code>.</p> <p>This structure allows for significant flexibility. For instance, one could implement a general <code>reduce</code> aggregation that takes Python expressions for an initial value and a step function, operating on the list of values collected for a group.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please feel free to submit a pull request or open an issue.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License.</p>"},{"location":"reference/","title":"API Reference","text":"<p>ja (JSONL Algebra)</p> <p>A Python package for performing relational algebra operations on lists of JSON objects (JSONL data).</p>"},{"location":"reference/#ja.difference","title":"<code>difference(a, b)</code>","text":"<p>Returns rows present in the first relation but not in the second. Row comparison is based on their hashable representation.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>Relation</code> <p>The first relation (list of rows).</p> required <code>b</code> <code>Relation</code> <p>The second relation (list of rows), whose rows will be excluded from 'a'.</p> required <p>Returns:</p> Type Description <code>Relation</code> <p>A new relation containing rows from 'a' that are not in 'b'.</p> Source code in <code>ja/core.py</code> <pre><code>def difference(a: Relation, b: Relation) -&gt; Relation:\n    \"\"\"\n    Returns rows present in the first relation but not in the second.\n    Row comparison is based on their hashable representation.\n\n    Args:\n        a: The first relation (list of rows).\n        b: The second relation (list of rows), whose rows will be excluded from 'a'.\n\n    Returns:\n        A new relation containing rows from 'a' that are not in 'b'.\n    \"\"\"\n    b_set = {_row_to_hashable_key(r) for r in b}\n    return [r for r in a if _row_to_hashable_key(r) not in b_set]\n</code></pre>"},{"location":"reference/#ja.distinct","title":"<code>distinct(relation)</code>","text":"<p>Removes duplicate rows from a relation. Row comparison is based on their hashable representation.</p> <p>Parameters:</p> Name Type Description Default <code>relation</code> <code>Relation</code> <p>The input relation (list of rows).</p> required <p>Returns:</p> Type Description <code>Relation</code> <p>A new relation with duplicate rows removed. The first occurrence of</p> <code>Relation</code> <p>each unique row is preserved.</p> Source code in <code>ja/core.py</code> <pre><code>def distinct(relation: Relation) -&gt; Relation:\n    \"\"\"\n    Removes duplicate rows from a relation.\n    Row comparison is based on their hashable representation.\n\n    Args:\n        relation: The input relation (list of rows).\n\n    Returns:\n        A new relation with duplicate rows removed. The first occurrence of\n        each unique row is preserved.\n    \"\"\"\n    seen = set()\n    out = []\n    for row in relation:\n        key = _row_to_hashable_key(row)\n        if key not in seen:\n            seen.add(key)\n            out.append(row)\n    return out\n</code></pre>"},{"location":"reference/#ja.groupby_agg","title":"<code>groupby_agg(relation, group_by_key, aggregations)</code>","text":"<p>Groups rows by a key and performs specified aggregations on other columns.</p> <p>This function works in two main passes: 1. Data Collection Pass: Iterates through the input relation, grouping rows    by the <code>group_by_key</code>. For each group, it collects the necessary data    for each specified aggregation (e.g., a list of values for 'sum', the    first value for 'first'). It also maintains a count of items in each group. 2. Aggregation Processing Pass: Iterates through the collected grouped data.    For each group and each specified aggregation, it retrieves the collected    data and applies the corresponding aggregation function (obtained via    <code>AGGREGATION_DISPATCHER</code> or special handling for 'count') to compute    the final aggregated value.</p> <p>The resulting relation contains one row per unique value of <code>group_by_key</code>, with columns for the group key and each specified aggregation.</p> <p>Parameters:</p> Name Type Description Default <code>relation</code> <code>Relation</code> <p>The input relation (list of rows/dictionaries).</p> required <code>group_by_key</code> <code>str</code> <p>The column name (key in the dictionaries) to group by.</p> required <code>aggregations</code> <code>List[Tuple[str, ...]]</code> <p>A list of tuples, where each tuple specifies an aggregation           to perform. The structure of the tuple is typically:           <code>(agg_func_name: str, agg_col_name: str, *extra_args: Any)</code>           - <code>agg_func_name</code>: The name of the aggregation function             (e.g., \"sum\", \"list\", \"count\").           - <code>agg_col_name</code>: The name of the column on which to perform             the aggregation. For \"count\", this is often ignored or             can be an empty string.           - <code>*extra_args</code>: Optional additional arguments that might be             required by specific aggregation functions (e.g., for a             future \"reduce\" function, these could be expression strings).</p> <pre><code>      Supported `agg_func_name` values are defined as keys in\n      `AGGREGATION_DISPATCHER`, plus \"count\".\n</code></pre> required <p>Returns:</p> Type Description <code>Relation</code> <p>A new relation (list of rows) where each row represents a group and</p> <code>Relation</code> <p>contains the group_by_key value along with the results of the</p> <code>Relation</code> <p>specified aggregations. Aggregation result columns are typically named</p> <code>Relation</code> <p><code>f\"{agg_func_name}_{agg_col_name}\"</code> (e.g., \"sum_amount\") or just</p> <code>Relation</code> <p><code>agg_func_name</code> if <code>agg_col_name</code> is empty (common for \"count\").</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an unsupported <code>agg_func_name</code> is provided or if         an aggregation function encounters an issue (e.g., trying         to sum non-numeric data that isn't None).</p> Source code in <code>ja/groupby.py</code> <pre><code>def groupby_agg(relation: Relation, group_by_key: str, aggregations: List[Tuple[str, ...]]) -&gt; Relation:\n    \"\"\"\n    Groups rows by a key and performs specified aggregations on other columns.\n\n    This function works in two main passes:\n    1. Data Collection Pass: Iterates through the input relation, grouping rows\n       by the `group_by_key`. For each group, it collects the necessary data\n       for each specified aggregation (e.g., a list of values for 'sum', the\n       first value for 'first'). It also maintains a count of items in each group.\n    2. Aggregation Processing Pass: Iterates through the collected grouped data.\n       For each group and each specified aggregation, it retrieves the collected\n       data and applies the corresponding aggregation function (obtained via\n       `AGGREGATION_DISPATCHER` or special handling for 'count') to compute\n       the final aggregated value.\n\n    The resulting relation contains one row per unique value of `group_by_key`,\n    with columns for the group key and each specified aggregation.\n\n    Args:\n        relation: The input relation (list of rows/dictionaries).\n        group_by_key: The column name (key in the dictionaries) to group by.\n        aggregations: A list of tuples, where each tuple specifies an aggregation\n                      to perform. The structure of the tuple is typically:\n                      `(agg_func_name: str, agg_col_name: str, *extra_args: Any)`\n                      - `agg_func_name`: The name of the aggregation function\n                        (e.g., \"sum\", \"list\", \"count\").\n                      - `agg_col_name`: The name of the column on which to perform\n                        the aggregation. For \"count\", this is often ignored or\n                        can be an empty string.\n                      - `*extra_args`: Optional additional arguments that might be\n                        required by specific aggregation functions (e.g., for a\n                        future \"reduce\" function, these could be expression strings).\n\n                      Supported `agg_func_name` values are defined as keys in\n                      `AGGREGATION_DISPATCHER`, plus \"count\".\n\n    Returns:\n        A new relation (list of rows) where each row represents a group and\n        contains the group_by_key value along with the results of the\n        specified aggregations. Aggregation result columns are typically named\n        `f\"{agg_func_name}_{agg_col_name}\"` (e.g., \"sum_amount\") or just\n        `agg_func_name` if `agg_col_name` is empty (common for \"count\").\n\n    Raises:\n        ValueError: If an unsupported `agg_func_name` is provided or if\n                    an aggregation function encounters an issue (e.g., trying\n                    to sum non-numeric data that isn't None).\n    \"\"\"\n    grouped_data: Dict[Any, Dict[str, Any]] = {}\n\n    # Pass 1: Collect data for aggregation\n    for row in relation:\n        key_value = row.get(group_by_key)\n        group = grouped_data.setdefault(key_value, {group_by_key: key_value})\n        # _values stores the raw data needed for each aggregation within the group\n        group_values = group.setdefault(\"_values\", {}) \n\n        # Always maintain a count for the group\n        group_values.setdefault(\"_count\", 0)\n        group_values[\"_count\"] += 1\n\n        for agg_spec in aggregations:\n            agg_func = agg_spec[0]\n            # Ensure agg_col is present, default to empty string if not (e.g. for count)\n            agg_col = agg_spec[1] if len(agg_spec) &gt; 1 else \"\" \n\n            if agg_func == \"count\": \n                continue # Count is handled by _count increment above\n\n            val = row.get(agg_col)\n            # storage_key_for_agg is used to store the collected data for a specific (agg_func, agg_col) pair\n            storage_key_for_agg = f\"{agg_func}_{agg_col}\" \n\n            if agg_func in [\"sum\", \"avg\", \"min\", \"max\", \"list\"]:\n                # These aggregations collect all values from agg_col into a list\n                group_values.setdefault(storage_key_for_agg, []).append(val)\n            elif agg_func == \"first\":\n                # Store only the first encountered value for this agg_col in the group\n                if storage_key_for_agg not in group_values:\n                    group_values[storage_key_for_agg] = val\n            elif agg_func == \"last\":\n                # Always store/overwrite with the latest value for this agg_col in the group\n                group_values[storage_key_for_agg] = val\n            elif agg_func not in AGGREGATION_DISPATCHER: # Check for unknown agg functions early\n                 raise ValueError(f\"Unsupported aggregation function during collection: {agg_func}\")\n            # Else: If agg_func is in dispatcher but not explicitly handled above,\n            # it implies it doesn't need special data collection beyond what other\n            # similar functions might do, or it's an error in dispatcher setup.\n\n    # Pass 2: Process collected data to produce final aggregations\n    result_relation = []\n    for key_value, group_data_content in grouped_data.items():\n        processed_row: Row = {group_by_key: key_value}\n        collected_group_values = group_data_content.get(\"_values\", {})\n\n        for agg_spec in aggregations:\n            agg_func_name = agg_spec[0]\n            agg_col_name = agg_spec[1] if len(agg_spec) &gt; 1 else \"\"\n            # extra_args = agg_spec[2:] # For future use, e.g., a general reduce\n\n            output_col_name = f\"{agg_func_name}_{agg_col_name}\" if agg_col_name else agg_func_name\n\n            if agg_func_name == \"count\":\n                processed_row[output_col_name] = collected_group_values.get(\"_count\", 0)\n            elif agg_func_name in AGGREGATION_DISPATCHER:\n                aggregator_func = AGGREGATION_DISPATCHER[agg_func_name]\n                # Key used to retrieve the raw data collected in Pass 1\n                raw_data_storage_key = f\"{agg_func_name}_{agg_col_name}\"\n\n                if agg_func_name in [\"first\", \"last\"]:\n                    # For 'first'/'last', the stored data is the single value itself\n                    data_to_aggregate = collected_group_values.get(raw_data_storage_key) # Defaults to None\n                else: \n                    # For list-based aggregations ('sum', 'avg', 'min', 'max', 'list')\n                    data_to_aggregate = collected_group_values.get(raw_data_storage_key, [])\n\n                # If aggregator_func needed extra_args (e.g. for a future 'reduce'),\n                # they would be passed here:\n                # processed_row[output_col_name] = aggregator_func(data_to_aggregate, *extra_args)\n                processed_row[output_col_name] = aggregator_func(data_to_aggregate)\n            else:\n                # This case should ideally not be reached if the collection phase\n                # and dispatcher are correctly set up.\n                raise ValueError(f\"Unsupported aggregation function during processing: {agg_func_name}\")\n\n        result_relation.append(processed_row)\n\n    return result_relation\n</code></pre>"},{"location":"reference/#ja.intersection","title":"<code>intersection(a, b)</code>","text":"<p>Returns rows common to both relations. Row comparison is based on their hashable representation.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>Relation</code> <p>The first relation (list of rows).</p> required <code>b</code> <code>Relation</code> <p>The second relation (list of rows).</p> required <p>Returns:</p> Type Description <code>Relation</code> <p>A new relation containing only rows that are present in both 'a' and 'b'.</p> Source code in <code>ja/core.py</code> <pre><code>def intersection(a: Relation, b: Relation) -&gt; Relation:\n    \"\"\"\n    Returns rows common to both relations.\n    Row comparison is based on their hashable representation.\n\n    Args:\n        a: The first relation (list of rows).\n        b: The second relation (list of rows).\n\n    Returns:\n        A new relation containing only rows that are present in both 'a' and 'b'.\n    \"\"\"\n    b_set = {_row_to_hashable_key(r) for r in b}\n    return [r for r in a if _row_to_hashable_key(r) in b_set]\n</code></pre>"},{"location":"reference/#ja.join","title":"<code>join(left, right, on)</code>","text":"<p>Combines rows from two relations based on specified join conditions.</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <code>Relation</code> <p>The left relation (list of rows).</p> required <code>right</code> <code>Relation</code> <p>The right relation (list of rows).</p> required <code>on</code> <code>List[Tuple[str, str]]</code> <p>A list of tuples, where each tuple (left_col, right_col) specifies the columns to join on.</p> required <p>Returns:</p> Type Description <code>Relation</code> <p>A new relation containing the merged rows that satisfy the join conditions.</p> <code>Relation</code> <p>The resulting row initially contains all columns from the left row.</p> <code>Relation</code> <p>Then, columns from the matching right row are considered: if a right</p> <code>Relation</code> <p>column's name is not present in the left row's columns AND is not one</p> <code>Relation</code> <p>of the column names used on the right side of the join condition (from</p> <code>Relation</code> <p>the <code>on</code> parameter), it is added to the result.</p> Source code in <code>ja/core.py</code> <pre><code>def join(left: Relation, right: Relation, on: List[Tuple[str, str]]) -&gt; Relation:\n    \"\"\"\n    Combines rows from two relations based on specified join conditions.\n\n    Args:\n        left: The left relation (list of rows).\n        right: The right relation (list of rows).\n        on: A list of tuples, where each tuple (left_col, right_col)\n            specifies the columns to join on.\n\n    Returns:\n        A new relation containing the merged rows that satisfy the join conditions.\n        The resulting row initially contains all columns from the left row.\n        Then, columns from the matching right row are considered: if a right\n        column's name is not present in the left row's columns AND is not one\n        of the column names used on the right side of the join condition (from\n        the `on` parameter), it is added to the result.\n    \"\"\"\n    right_index = {}\n    for r_row_build_idx in right:\n        key_tuple = tuple(r_row_build_idx[r_col] for _, r_col in on)\n        right_index.setdefault(key_tuple, []).append(r_row_build_idx)\n\n    result = []\n    # Pre-calculate the set of right column names that are part of the join condition\n    right_join_key_names = {r_col for _, r_col in on}\n\n    for l_row in left:\n        key_tuple = tuple(l_row[l_col] for l_col, _ in on)\n        for r_row in right_index.get(key_tuple, []):\n            merged_row = dict(l_row)  # Start with a copy of the left row\n\n            # Add columns from the right row if they don't collide with left row's columns\n            # and are not themselves right-side join keys.\n            for r_key, r_val in r_row.items():\n                if r_key not in merged_row and r_key not in right_join_key_names:\n                    merged_row[r_key] = r_val\n            result.append(merged_row)\n    return result\n</code></pre>"},{"location":"reference/#ja.product","title":"<code>product(a, b)</code>","text":"<p>Computes the Cartesian product of two relations.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>Relation</code> <p>The first relation (list of rows).</p> required <code>b</code> <code>Relation</code> <p>The second relation (list of rows).</p> required <p>Returns:</p> Type Description <code>Relation</code> <p>A new relation containing all combinations of rows from 'a' and 'b'.</p> Source code in <code>ja/core.py</code> <pre><code>def product(a: Relation, b: Relation) -&gt; Relation:\n    \"\"\"\n    Computes the Cartesian product of two relations.\n\n    Args:\n        a: The first relation (list of rows).\n        b: The second relation (list of rows).\n\n    Returns:\n        A new relation containing all combinations of rows from 'a' and 'b'.\n    \"\"\"\n    out = []\n    for r1 in a:\n        for r2 in b:\n            merged = dict(r1)\n            for k, v in r2.items():\n                # avoid key collision by prefixing\n                merged[f\"b_{k}\" if k in r1 else k] = v\n            out.append(merged)\n    return out\n</code></pre>"},{"location":"reference/#ja.project","title":"<code>project(relation, columns)</code>","text":"<p>Selects specific columns from a relation.</p> <p>Parameters:</p> Name Type Description Default <code>relation</code> <code>Relation</code> <p>The input relation (list of rows).</p> required <code>columns</code> <code>List[str]</code> <p>A list of column names to include in the result.</p> required <p>Returns:</p> Type Description <code>Relation</code> <p>A new relation containing only the specified columns for each row.</p> <code>Relation</code> <p>If a row does not contain a specified column, it's omitted for that row.</p> Source code in <code>ja/core.py</code> <pre><code>def project(relation: Relation, columns: List[str]) -&gt; Relation:\n    \"\"\"\n    Selects specific columns from a relation.\n\n    Args:\n        relation: The input relation (list of rows).\n        columns: A list of column names to include in the result.\n\n    Returns:\n        A new relation containing only the specified columns for each row.\n        If a row does not contain a specified column, it's omitted for that row.\n    \"\"\"\n    return [{col: row[col] for col in columns if col in row} for row in relation]\n</code></pre>"},{"location":"reference/#ja.rename","title":"<code>rename(relation, renames)</code>","text":"<p>Renames columns in a relation.</p> <p>Parameters:</p> Name Type Description Default <code>relation</code> <code>Relation</code> <p>The input relation (list of rows).</p> required <code>renames</code> <code>Dict[str, str]</code> <p>A dictionary mapping old column names to new column names.</p> required <p>Returns:</p> Type Description <code>Relation</code> <p>A new relation with specified columns renamed.</p> Source code in <code>ja/core.py</code> <pre><code>def rename(relation: Relation, renames: Dict[str, str]) -&gt; Relation:\n    \"\"\"\n    Renames columns in a relation.\n\n    Args:\n        relation: The input relation (list of rows).\n        renames: A dictionary mapping old column names to new column names.\n\n    Returns:\n        A new relation with specified columns renamed.\n    \"\"\"\n    return [{renames.get(k, k): v for k, v in row.items()} for row in relation]\n</code></pre>"},{"location":"reference/#ja.select","title":"<code>select(relation, predicate)</code>","text":"<p>Filters rows from a relation based on a predicate.</p> <p>Parameters:</p> Name Type Description Default <code>relation</code> <code>Relation</code> <p>The input relation (list of rows).</p> required <code>predicate</code> <code>Callable[[Row], bool]</code> <p>A function that takes a row and returns True if the row        should be included in the result.</p> required <p>Returns:</p> Type Description <code>Relation</code> <p>A new relation containing only the rows for which the predicate is True.</p> Source code in <code>ja/core.py</code> <pre><code>def select(relation: Relation, predicate: Callable[[Row], bool]) -&gt; Relation:\n    \"\"\"\n    Filters rows from a relation based on a predicate.\n\n    Args:\n        relation: The input relation (list of rows).\n        predicate: A function that takes a row and returns True if the row\n                   should be included in the result.\n\n    Returns:\n        A new relation containing only the rows for which the predicate is True.\n    \"\"\"\n    return [row for row in relation if predicate(row)]\n</code></pre>"},{"location":"reference/#ja.sort_by","title":"<code>sort_by(relation, keys)</code>","text":"<p>Sorts a relation by specified keys.</p> <p>Parameters:</p> Name Type Description Default <code>relation</code> <code>Relation</code> <p>The input relation (list of rows).</p> required <code>keys</code> <code>List[str]</code> <p>A list of column names to sort by. The sort is performed in   the order of the columns specified. Missing values (None)   are sorted before non-None values.</p> required <p>Returns:</p> Type Description <code>Relation</code> <p>A new relation sorted by the specified keys.</p> Source code in <code>ja/core.py</code> <pre><code>def sort_by(relation: Relation, keys: List[str]) -&gt; Relation:\n    \"\"\"\n    Sorts a relation by specified keys.\n\n    Args:\n        relation: The input relation (list of rows).\n        keys: A list of column names to sort by. The sort is performed in\n              the order of the columns specified. Missing values (None)\n              are sorted before non-None values.\n\n    Returns:\n        A new relation sorted by the specified keys.\n    \"\"\"\n    def sort_key_func(row: Row) -&gt; tuple:\n        key_parts = []\n        for k in keys:\n            value = row.get(k)\n            if value is None:\n                # Sort None values first by using a lower first element in the tuple part\n                key_parts.append((0, None)) \n            else:\n                key_parts.append((1, value))\n        return tuple(key_parts)\n\n    return sorted(relation, key=sort_key_func)\n</code></pre>"},{"location":"reference/#ja.union","title":"<code>union(a, b)</code>","text":"<p>Returns all rows from two relations; duplicates may be present. This is equivalent to list concatenation. For a set union (distinct rows), pipe the result through <code>distinct</code>.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>Relation</code> <p>The first relation (list of rows).</p> required <code>b</code> <code>Relation</code> <p>The second relation (list of rows).</p> required <p>Returns:</p> Type Description <code>Relation</code> <p>A new relation containing all rows from both input relations.</p> Source code in <code>ja/core.py</code> <pre><code>def union(a: Relation, b: Relation) -&gt; Relation:\n    \"\"\"\n    Returns all rows from two relations; duplicates may be present.\n    This is equivalent to list concatenation. For a set union (distinct rows),\n    pipe the result through `distinct`.\n\n    Args:\n        a: The first relation (list of rows).\n        b: The second relation (list of rows).\n\n    Returns:\n        A new relation containing all rows from both input relations.\n    \"\"\"\n    return a + b\n</code></pre>"}]}
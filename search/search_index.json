{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ja - JSONL Algebra","text":"<p>ja is a lightweight command-line tool and Python library for performing relational algebra operations on JSONL (JSON Lines) data. It's designed to be a simple, dependency-free alternative for common data manipulation tasks, inspired by tools like <code>jq</code> and traditional SQL.</p>"},{"location":"#features","title":"Features","text":"<ul> <li> <p>Perform common relational algebra operations: select, project, join, union, intersection, difference, distinct, sort, product, and group by with aggregations.</p> </li> <li> <p><code>groupby</code>: A powerful feature that allows you to group data by one or more keys and perform various aggregations on the grouped data.</p> </li> <li>By default, includes <code>sum</code>, <code>avg</code>, <code>min</code>, <code>max</code>, <code>count</code>, <code>list</code> (collect all values), <code>first</code> (first value in group), <code>last</code> (last value in group) aggregations.</li> <li>Can be extended with custom aggregation functions. See \"Extending Group By Aggregations\" section.</li> <li>Works with JSONL files or piped data from stdin/stdout.</li> <li>Can be used as a CLI tool or as a Python library.</li> <li>No external dependencies.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>There are two main ways to install <code>ja</code>:</p>"},{"location":"#for-users-from-pypi","title":"For users (from PyPI):","text":"<p>You can install the package directly from PyPI (Python Package Index) using pip.</p> <pre><code>pip install jsonl-algebra\n</code></pre>"},{"location":"#for-developers-from-local-repository","title":"For developers (from local repository):**","text":"<p>If you have cloned this repository and want to install it for development or from local sources:</p> <pre><code>pip install .\n</code></pre> <p>To install in editable mode for development:</p> <pre><code>pip install -e .\n</code></pre>"},{"location":"#cli-usage","title":"CLI Usage","text":"<p>The <code>ja</code> command-line tool provides several subcommands for different operations.</p> <p>General Syntax: <code>ja &lt;command&gt; [options] [file(s)]</code></p> <p>If <code>file</code> is omitted for commands that expect a single input, <code>ja</code> reads from stdin.</p>"},{"location":"#examples","title":"Examples","text":"<ul> <li> <p>Select rows where 'amount' is greater than 100:</p> <p><code>bash cat data.jsonl | ja select 'amount &gt; 100'</code></p> <p><code>bash ja select 'amount &gt; 100' data.jsonl</code></p> </li> <li> <p>Project 'id' and 'name' columns:</p> <p><code>bash cat data.jsonl | ja project id,name</code></p> </li> <li> <p>Join two files on a common key:</p> <p><code>bash ja join users.jsonl orders.jsonl --on user_id=customer_id</code></p> </li> <li> <p>Group by 'category' and count items:</p> <p><code>bash cat products.jsonl | ja groupby category --agg count</code></p> </li> <li> <p>Group by 'category', count items, and list all product names:</p> <p><code>bash cat products.jsonl | ja groupby category --agg count --agg list:name\\</code></p> <p>This will produce output like: <code>{\"category\": \"electronics\", \"count\": 5, \"list_name\": [\"laptop\", \"mouse\", ...]}</code></p> </li> <li> <p>Group by 'user_id' and get the first action:</p> <p><code>bash cat user_actions.jsonl | ja groupby user_id --agg first:action</code></p> </li> <li> <p>Sort data by 'timestamp':</p> <p><code>bash cat logs.jsonl | ja sort timestamp</code></p> </li> <li> <p>Infer the schema of a JSONL file: <code>bash     ja schema data.jsonl</code>     Or from stdin:     <code>bash     cat data.jsonl | ja schema</code></p> </li> <li> <p>Start an interactive REPL session: <code>bash     ja repl</code>     Inside the REPL, you can build a pipeline:     <code>ja&gt; from data.jsonl     ja&gt; select 'age &gt; 30'     ja&gt; project name,email     ja&gt; execute --lines=5      ja&gt; compile</code></p> </li> <li> <p>Export JSONL to a JSON array: <code>bash     ja export to-array data.jsonl &gt; data.json</code></p> </li> <li> <p>Convert a JSON array back to JSONL: <code>bash     ja export to-jsonl data.json &gt; data.jsonl</code></p> </li> <li> <p>Explode a JSONL file into a directory of individual JSON files: <code>bash     ja export explode data.jsonl -o data_exploded</code>     This will create a directory <code>data_exploded</code> with files like <code>item-0.json</code>, <code>item-1.json</code>, etc.</p> </li> <li> <p>Implode a directory of JSON files back into a JSONL stream: <code>bash     ja export implode data_exploded --add-filename-key source_file &gt; combined.jsonl</code></p> </li> </ul>"},{"location":"#available-commands","title":"Available Commands","text":"<ul> <li><code>select</code>: Filter rows based on a Python expression.</li> <li><code>project</code>: Select specific columns.</li> <li><code>join</code>: Join two relations on specified keys.</li> <li><code>rename</code>: Rename columns.</li> <li><code>union</code>: Combine two relations (all rows).</li> <li><code>difference</code>: Rows in the first relation but not the second.</li> <li><code>distinct</code>: Remove duplicate rows.</li> <li><code>intersection</code>: Rows common to both relations.</li> <li><code>sort</code> (maps to <code>sort_by</code>): Sort a relation by specified keys.</li> <li><code>product</code>: Cartesian product of two relations.</li> <li><code>groupby</code> (maps to <code>groupby_agg</code>): Group rows by a key and perform aggregations.</li> <li><code>schema</code>: Infer and display the schema of a JSONL file.</li> <li><code>repl</code>: Start an interactive REPL session to build command pipelines.</li> <li><code>export</code>: A group of commands for transforming data formats.<ul> <li><code>to-array</code>: Convert JSONL to a single JSON array.</li> <li><code>to-jsonl</code>: Convert a JSON array (from a file or stdin) to JSONL.</li> <li><code>explode</code>: Export each line of a JSONL file to a separate JSON file in a directory.</li> <li><code>implode</code>: Combine JSON files from a directory into a JSONL stream.</li> </ul> </li> </ul> <p>Use <code>ja &lt;command&gt; --help</code> or <code>ja export &lt;subcommand&gt; --help</code> for more details on specific commands.</p>"},{"location":"#programmatic-api-usage","title":"Programmatic API Usage","text":"<p>You can also use <code>ja</code> as a Python library:</p> <pre><code>import ja\nfrom ja import Row, Relation # For type hinting if needed\n\n# Load data from JSONL files\n# users_data = ja.read_jsonl(\"users.jsonl\")\n# orders_data = ja.read_jsonl(\"orders.jsonl\")\n\n# Example data (replace with ja.read_jsonl for actual files)\nusers_data: Relation = [\n    {\"user_id\": 1, \"name\": \"Alice\", \"status\": \"active\", \"email\": \"alice@example.com\"},\n    {\"user_id\": 2, \"name\": \"Bob\", \"status\": \"inactive\", \"email\": \"bob@example.com\"},\n    {\"user_id\": 1, \"name\": \"Alice\", \"status\": \"active\", \"email\": \"alice@example.com\"} # Duplicate for distinct example\n]\norders_data: Relation = [\n    {\"order_id\": 101, \"customer_id\": 1, \"item\": \"Book\", \"quantity\": 1},\n    {\"order_id\": 102, \"customer_id\": 2, \"item\": \"Pen\", \"quantity\": 5},\n    {\"order_id\": 103, \"customer_id\": 1, \"item\": \"Notebook\", \"quantity\": 2},\n    {\"order_id\": 104, \"customer_id\": 1, \"item\": \"Book\", \"quantity\": 3}\n]\n\n\n# Example: Select active users\nactive_users = ja.select(users_data, lambda row: row.get(\"status\") == \"active\")\n# active_users will be:\n# [{'user_id': 1, 'name': 'Alice', 'status': 'active', 'email': 'alice@example.com'},\n#  {'user_id': 1, 'name': 'Alice', 'status': 'active', 'email': 'alice@example.com'}]\n\n# Example: Project name and email from distinct active users\ndistinct_active_users = ja.distinct(active_users)\nuser_info = ja.project(distinct_active_users, [\"name\", \"email\"])\n# user_info will be:\n# [{'name': 'Alice', 'email': 'alice@example.com'}]\n\n# Example: Join distinct active users with their orders\n# Ensure the join key 'user_id' is present in the projected active_users relation\nactive_users_with_id = ja.project(distinct_active_users, [\"user_id\", \"name\", \"email\"])\njoined_data = ja.join(active_users_with_id, orders_data, on=[(\"user_id\", \"customer_id\")])\n# joined_data will be:\n# [{'user_id': 1, 'name': 'Alice', 'email': 'alice@example.com', 'order_id': 101, 'item': 'Book', 'quantity': 1},\n#  {'user_id': 1, 'name': 'Alice', 'email': 'alice@example.com', 'order_id': 103, 'item': 'Notebook', 'quantity': 2},\n#  {'user_id': 1, 'name': 'Alice', 'email': 'alice@example.com', 'order_id': 104, 'item': 'Book', 'quantity': 3}]\n\n# Example: Group joined data by user and sum quantities, list items\ngrouped_orders = ja.groupby_agg(\n    joined_data,\n    group_by_key=\"user_id\",\n    aggregations=[\n        (\"sum\", \"quantity\"),\n        (\"list\", \"item\"),\n        (\"count\", \"\") # Count groups\n    ]\n)\n# grouped_orders might be (depending on Alice's orders):\n# [{'user_id': 1, 'sum_quantity': 6, 'list_item': ['Book', 'Notebook', 'Book'], 'count': 3}]\n\n\n# Print results (example)\nfor row in grouped_orders:\n    print(row)\n\n# Available functions mirror the CLI commands:\n# ja.select, ja.project, ja.join, ja.rename, ja.union,\n# ja.difference, ja.distinct, ja.intersection, ja.sort_by,\n# ja.product, ja.groupby_agg\n</code></pre>"},{"location":"#extending-group-by-aggregations","title":"Extending Group By Aggregations","text":"<p>By default, <code>ja</code> supports several built-in aggregation functions for the <code>groupby_agg</code> operation. These include: <code>count</code>, <code>sum</code>, <code>avg</code>, <code>min</code>, <code>max</code>, <code>list</code>, <code>first</code>, and <code>last</code>. Syntax for aggregations: <code>agg_name</code> (for count) or <code>agg_name:column_name</code> (e.g., <code>sum:price</code>, <code>list:product_id</code>).</p> <p>The <code>groupby_agg</code> functionality is designed to be extensible. The core logic resides in the <code>ja.groupby</code> module, which uses a dispatcher pattern.</p>"},{"location":"#define-an-aggregation-helper-function","title":"Define an aggregation helper function","text":"<p>This function will take the collected data for a group (typically a list of values, or a single value for aggregations like <code>first</code>/<code>last</code>) and return the aggregated result.</p> <p>For instance, if you want to add a custom aggregation function for calculating the median, you would define a function that takes a list of values and returns the median.</p> <pre><code>def _my_custom_median_agg(collected_values: list) -&gt; float | None:\n    numeric_vals = sorted([v for v in collected_values if isinstance(v, (int, float))])\n    if not numeric_vals:\n        return None\n    n = len(numeric_vals)\n    mid = n // 2\n    if n % 2 == 0:\n        return (numeric_vals[mid - 1] + numeric_vals[mid]) / 2\n    else:\n        return numeric_vals[mid]\n</code></pre> <p>Now, register it (if modifying <code>ja</code> directly or for illustration):</p> <pre><code># In ja/groupby.py\nAGGREGATION_DISPATCHER = {\n    # ...\n    \"median\": _my_custom_median_agg,\n}\n</code></pre> <p>For programmatic use with your own <code>ja</code> instance or a forked version, you could potentially expose a way to register custom aggregators or pass them directly if the API supported it.</p> <p>If your aggregation requires a specific way of collecting data during the first pass of <code>groupby_agg</code> (different from how <code>list</code>, <code>first</code>, or <code>last</code> collect data), you would need to modify the data collection logic in <code>ja.groupby.groupby_agg</code>.</p> <p>This structure allows for significant flexibility. For instance, one could implement a general <code>reduce</code> aggregation that takes Python expressions for an initial value and a step function, operating on the list of values collected for a group.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please feel free to submit a pull request or open an issue.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License.</p>"},{"location":"reference/","title":"API Reference","text":"<p>JSONL Algebra - Relational algebra operations for JSONL data.</p> <p>A Python package for performing relational algebra operations on lists of JSON objects (JSONL data). Provides both a CLI and a library interface for data manipulation, schema inference, and format conversion.</p> <p>This package allows you to: - Perform relational operations like select, project, join, union, etc. - Infer and validate JSON schemas from data - Convert between various data formats (CSV, JSON arrays, directories) - Work with data interactively via REPL or programmatically via library functions</p> Example <p>from ja import select, project data = [{\"name\": \"Alice\", \"age\": 30}, {\"name\": \"Bob\", \"age\": 25}] young_people = select(data, \"age &lt; <code>30</code>\") names_only = project(young_people, [\"name\"])</p>"},{"location":"reference/#ja.difference","title":"<code>difference(a, b)</code>","text":"<p>Return rows present in the first relation but not in the second.</p> <p>Performs set difference operation, removing from the first relation any rows that also appear in the second relation.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>Relation</code> <p>The first relation (list of dictionaries).</p> required <code>b</code> <code>Relation</code> <p>The second relation (list of dictionaries), whose rows will be excluded from 'a'.</p> required <p>Returns:</p> Type Description <code>Relation</code> <p>A new relation containing rows from 'a' that are not in 'b'.</p> Example <p>a = [{\"name\": \"Alice\"}, {\"name\": \"Bob\"}] b = [{\"name\": \"Alice\"}] difference(a, b) [{\"name\": \"Bob\"}]</p> Source code in <code>ja/core.py</code> <pre><code>def difference(a: Relation, b: Relation) -&gt; Relation:\n    \"\"\"Return rows present in the first relation but not in the second.\n\n    Performs set difference operation, removing from the first relation\n    any rows that also appear in the second relation.\n\n    Args:\n        a: The first relation (list of dictionaries).\n        b: The second relation (list of dictionaries), whose rows will be excluded from 'a'.\n\n    Returns:\n        A new relation containing rows from 'a' that are not in 'b'.\n\n    Example:\n        &gt;&gt;&gt; a = [{\"name\": \"Alice\"}, {\"name\": \"Bob\"}]\n        &gt;&gt;&gt; b = [{\"name\": \"Alice\"}]\n        &gt;&gt;&gt; difference(a, b)\n        [{\"name\": \"Bob\"}]\n    \"\"\"\n    b_set = {_row_to_hashable_key(r) for r in b}\n    return [r for r in a if _row_to_hashable_key(r) not in b_set]\n</code></pre>"},{"location":"reference/#ja.distinct","title":"<code>distinct(relation)</code>","text":"<p>Remove duplicate rows from a relation.</p> <p>Creates a new relation with duplicate rows removed, preserving the first occurrence of each unique row.</p> <p>Parameters:</p> Name Type Description Default <code>relation</code> <code>Relation</code> <p>The input relation (list of dictionaries).</p> required <p>Returns:</p> Type Description <code>Relation</code> <p>A new relation with duplicate rows removed.</p> Example <p>data = [{\"name\": \"Alice\"}, {\"name\": \"Alice\"}, {\"name\": \"Bob\"}] distinct(data) [{\"name\": \"Alice\"}, {\"name\": \"Bob\"}]</p> Source code in <code>ja/core.py</code> <pre><code>def distinct(relation: Relation) -&gt; Relation:\n    \"\"\"Remove duplicate rows from a relation.\n\n    Creates a new relation with duplicate rows removed, preserving the\n    first occurrence of each unique row.\n\n    Args:\n        relation: The input relation (list of dictionaries).\n\n    Returns:\n        A new relation with duplicate rows removed.\n\n    Example:\n        &gt;&gt;&gt; data = [{\"name\": \"Alice\"}, {\"name\": \"Alice\"}, {\"name\": \"Bob\"}]\n        &gt;&gt;&gt; distinct(data)\n        [{\"name\": \"Alice\"}, {\"name\": \"Bob\"}]\n    \"\"\"\n    seen = set()\n    out = []\n    for row in relation:\n        key = _row_to_hashable_key(row)\n        if key not in seen:\n            seen.add(key)\n            out.append(row)\n    return out\n</code></pre>"},{"location":"reference/#ja.groupby_agg","title":"<code>groupby_agg(relation, group_by_key, aggregations)</code>","text":"<p>Group rows by a key and perform specified aggregations on other columns.</p> <p>This function works in two main passes: 1. Data Collection Pass: Groups rows by the <code>group_by_key</code> and collects    the necessary data for each specified aggregation. 2. Aggregation Processing Pass: Applies aggregation functions to compute    the final aggregated values for each group.</p> <p>Parameters:</p> Name Type Description Default <code>relation</code> <code>Relation</code> <p>The input relation (list of dictionaries).</p> required <code>group_by_key</code> <code>str</code> <p>The column name to group by.</p> required <code>aggregations</code> <code>List[Tuple[str, ...]]</code> <p>A list of tuples specifying aggregations to perform.           Each tuple format: (agg_func_name, agg_col_name, *extra_args)           - agg_func_name: Name of aggregation function (e.g., \"sum\", \"count\")           - agg_col_name: Column name to aggregate (ignored for \"count\")           - extra_args: Additional arguments for the aggregation function</p> required <p>Returns:</p> Type Description <code>Relation</code> <p>A new relation with one row per unique group key value, containing</p> <code>Relation</code> <p>the group key and all requested aggregations.</p> Example <p>data = [{\"category\": \"A\", \"value\": 10}, {\"category\": \"A\", \"value\": 20}, {\"category\": \"B\", \"value\": 30}] groupby_agg(data, \"category\", [(\"sum\", \"value\"), (\"count\", \"\")]) [{\"category\": \"A\", \"sum_value\": 30, \"count\": 2}, {\"category\": \"B\", \"sum_value\": 30, \"count\": 1}]</p> Source code in <code>ja/groupby.py</code> <pre><code>def groupby_agg(\n    relation: Relation, group_by_key: str, aggregations: List[Tuple[str, ...]]\n) -&gt; Relation:\n    \"\"\"Group rows by a key and perform specified aggregations on other columns.\n\n    This function works in two main passes:\n    1. Data Collection Pass: Groups rows by the `group_by_key` and collects\n       the necessary data for each specified aggregation.\n    2. Aggregation Processing Pass: Applies aggregation functions to compute\n       the final aggregated values for each group.\n\n    Args:\n        relation: The input relation (list of dictionaries).\n        group_by_key: The column name to group by.\n        aggregations: A list of tuples specifying aggregations to perform.\n                      Each tuple format: (agg_func_name, agg_col_name, *extra_args)\n                      - agg_func_name: Name of aggregation function (e.g., \"sum\", \"count\")\n                      - agg_col_name: Column name to aggregate (ignored for \"count\")\n                      - extra_args: Additional arguments for the aggregation function\n\n    Returns:\n        A new relation with one row per unique group key value, containing\n        the group key and all requested aggregations.\n\n    Example:\n        &gt;&gt;&gt; data = [{\"category\": \"A\", \"value\": 10}, {\"category\": \"A\", \"value\": 20}, {\"category\": \"B\", \"value\": 30}]\n        &gt;&gt;&gt; groupby_agg(data, \"category\", [(\"sum\", \"value\"), (\"count\", \"\")])\n        [{\"category\": \"A\", \"sum_value\": 30, \"count\": 2}, {\"category\": \"B\", \"sum_value\": 30, \"count\": 1}]\n    \"\"\"\n    grouped_data: Dict[Any, Dict[str, Any]] = {}\n\n    # Pass 1: Collect data for aggregation\n    for row in relation:\n        key_value = row.get(group_by_key)\n        group = grouped_data.setdefault(key_value, {group_by_key: key_value})\n        # _values stores the raw data needed for each aggregation within the group\n        group_values = group.setdefault(\"_values\", {})\n\n        # Always maintain a count for the group\n        group_values.setdefault(\"_count\", 0)\n        group_values[\"_count\"] += 1\n\n        for agg_spec in aggregations:\n            agg_func = agg_spec[0]\n            # Ensure agg_col is present, default to empty string if not (e.g. for count)\n            agg_col = agg_spec[1] if len(agg_spec) &gt; 1 else \"\"\n\n            if agg_func == \"count\":\n                continue  # Count is handled by _count increment above\n\n            val = row.get(agg_col)\n            # storage_key_for_agg is used to store the collected data for a specific (agg_func, agg_col) pair\n            storage_key_for_agg = f\"{agg_func}_{agg_col}\"\n\n            if agg_func in [\"sum\", \"avg\", \"min\", \"max\", \"list\"]:\n                # These aggregations collect all values from agg_col into a list\n                group_values.setdefault(storage_key_for_agg, []).append(val)\n            elif agg_func == \"first\":\n                # Store only the first encountered value for this agg_col in the group\n                if storage_key_for_agg not in group_values:\n                    group_values[storage_key_for_agg] = val\n            elif agg_func == \"last\":\n                # Always store/overwrite with the latest value for this agg_col in the group\n                group_values[storage_key_for_agg] = val\n            elif (\n                agg_func not in AGGREGATION_DISPATCHER\n            ):  # Check for unknown agg functions early\n                raise ValueError(\n                    f\"Unsupported aggregation function during collection: {agg_func}\"\n                )\n            # Else: If agg_func is in dispatcher but not explicitly handled above,\n            # it implies it doesn't need special data collection beyond what other\n            # similar functions might do, or it's an error in dispatcher setup.\n\n    # Pass 2: Process collected data to produce final aggregations\n    result_relation = []\n    for key_value, group_data_content in grouped_data.items():\n        processed_row: Row = {group_by_key: key_value}\n        collected_group_values = group_data_content.get(\"_values\", {})\n\n        for agg_spec in aggregations:\n            agg_func_name = agg_spec[0]\n            agg_col_name = agg_spec[1] if len(agg_spec) &gt; 1 else \"\"\n            # extra_args = agg_spec[2:] # For future use, e.g., a general reduce\n\n            output_col_name = (\n                f\"{agg_func_name}_{agg_col_name}\" if agg_col_name else agg_func_name\n            )\n\n            if agg_func_name == \"count\":\n                processed_row[output_col_name] = collected_group_values.get(\"_count\", 0)\n            elif agg_func_name in AGGREGATION_DISPATCHER:\n                aggregator_func = AGGREGATION_DISPATCHER[agg_func_name]\n                # Key used to retrieve the raw data collected in Pass 1\n                raw_data_storage_key = f\"{agg_func_name}_{agg_col_name}\"\n\n                if agg_func_name in [\"first\", \"last\"]:\n                    # For 'first'/'last', the stored data is the single value itself\n                    data_to_aggregate = collected_group_values.get(\n                        raw_data_storage_key\n                    )  # Defaults to None\n                else:\n                    # For list-based aggregations ('sum', 'avg', 'min', 'max', 'list')\n                    data_to_aggregate = collected_group_values.get(\n                        raw_data_storage_key, []\n                    )\n\n                # If aggregator_func needed extra_args (e.g. for a future 'reduce'),\n                # they would be passed here:\n                # processed_row[output_col_name] = aggregator_func(data_to_aggregate, *extra_args)\n                processed_row[output_col_name] = aggregator_func(data_to_aggregate)\n            else:\n                # This case should ideally not be reached if the collection phase\n                # and dispatcher are correctly set up.\n                raise ValueError(\n                    f\"Unsupported aggregation function during processing: {agg_func_name}\"\n                )\n\n        result_relation.append(processed_row)\n\n    return result_relation\n</code></pre>"},{"location":"reference/#ja.intersection","title":"<code>intersection(a, b)</code>","text":"<p>Return rows common to both relations.</p> <p>Creates a new relation containing only rows that are present in both input relations.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>Relation</code> <p>The first relation (list of dictionaries).</p> required <code>b</code> <code>Relation</code> <p>The second relation (list of dictionaries).</p> required <p>Returns:</p> Type Description <code>Relation</code> <p>A new relation containing only rows that are present in both 'a' and 'b'.</p> Example <p>a = [{\"name\": \"Alice\"}, {\"name\": \"Bob\"}] b = [{\"name\": \"Alice\"}, {\"name\": \"Carol\"}] intersection(a, b) [{\"name\": \"Alice\"}]</p> Source code in <code>ja/core.py</code> <pre><code>def intersection(a: Relation, b: Relation) -&gt; Relation:\n    \"\"\"Return rows common to both relations.\n\n    Creates a new relation containing only rows that are present in both\n    input relations.\n\n    Args:\n        a: The first relation (list of dictionaries).\n        b: The second relation (list of dictionaries).\n\n    Returns:\n        A new relation containing only rows that are present in both 'a' and 'b'.\n\n    Example:\n        &gt;&gt;&gt; a = [{\"name\": \"Alice\"}, {\"name\": \"Bob\"}]\n        &gt;&gt;&gt; b = [{\"name\": \"Alice\"}, {\"name\": \"Carol\"}]\n        &gt;&gt;&gt; intersection(a, b)\n        [{\"name\": \"Alice\"}]\n    \"\"\"\n    b_set = {_row_to_hashable_key(r) for r in b}\n    return [r for r in a if _row_to_hashable_key(r) in b_set]\n</code></pre>"},{"location":"reference/#ja.join","title":"<code>join(left, right, on)</code>","text":"<p>Combine rows from two relations based on specified join conditions.</p> <p>Performs an inner join between two relations, matching rows where the specified columns have equal values.</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <code>Relation</code> <p>The left relation (list of dictionaries).</p> required <code>right</code> <code>Relation</code> <p>The right relation (list of dictionaries).</p> required <code>on</code> <code>List[Tuple[str, str]]</code> <p>A list of tuples, where each tuple (left_col, right_col) specifies the columns to join on.</p> required <p>Returns:</p> Type Description <code>Relation</code> <p>A new relation containing the merged rows that satisfy the join conditions.</p> <code>Relation</code> <p>The resulting rows contain all columns from the left row, plus columns</p> <code>Relation</code> <p>from the matching right row (excluding right columns used in join conditions).</p> Example <p>left = [{\"id\": 1, \"name\": \"Alice\"}] right = [{\"user_id\": 1, \"score\": 95}] join(left, right, [(\"id\", \"user_id\")]) [{\"id\": 1, \"name\": \"Alice\", \"score\": 95}]</p> Source code in <code>ja/core.py</code> <pre><code>def join(left: Relation, right: Relation, on: List[Tuple[str, str]]) -&gt; Relation:\n    \"\"\"Combine rows from two relations based on specified join conditions.\n\n    Performs an inner join between two relations, matching rows where the\n    specified columns have equal values.\n\n    Args:\n        left: The left relation (list of dictionaries).\n        right: The right relation (list of dictionaries).\n        on: A list of tuples, where each tuple (left_col, right_col)\n            specifies the columns to join on.\n\n    Returns:\n        A new relation containing the merged rows that satisfy the join conditions.\n        The resulting rows contain all columns from the left row, plus columns\n        from the matching right row (excluding right columns used in join conditions).\n\n    Example:\n        &gt;&gt;&gt; left = [{\"id\": 1, \"name\": \"Alice\"}]\n        &gt;&gt;&gt; right = [{\"user_id\": 1, \"score\": 95}]\n        &gt;&gt;&gt; join(left, right, [(\"id\", \"user_id\")])\n        [{\"id\": 1, \"name\": \"Alice\", \"score\": 95}]\n    \"\"\"\n    right_index = {}\n    for r_row_build_idx in right:\n        key_tuple = tuple(r_row_build_idx[r_col] for _, r_col in on)\n        right_index.setdefault(key_tuple, []).append(r_row_build_idx)\n\n    result = []\n    # Pre-calculate the set of right column names that are part of the join condition\n    right_join_key_names = {r_col for _, r_col in on}\n\n    for l_row in left:\n        key_tuple = tuple(l_row[l_col] for l_col, _ in on)\n        for r_row in right_index.get(key_tuple, []):\n            merged_row = dict(l_row)  # Start with a copy of the left row\n\n            # Add columns from the right row if they don't collide with left row's columns\n            # and are not themselves right-side join keys.\n            for r_key, r_val in r_row.items():\n                if r_key not in merged_row and r_key not in right_join_key_names:\n                    merged_row[r_key] = r_val\n            result.append(merged_row)\n    return result\n</code></pre>"},{"location":"reference/#ja.product","title":"<code>product(a, b)</code>","text":"<p>Compute the Cartesian product of two relations.</p> <p>Creates all possible combinations of rows from the two input relations.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>Relation</code> <p>The first relation (list of dictionaries).</p> required <code>b</code> <code>Relation</code> <p>The second relation (list of dictionaries).</p> required <p>Returns:</p> Type Description <code>Relation</code> <p>A new relation containing all combinations of rows from 'a' and 'b'.</p> Example <p>a = [{\"x\": 1}] b = [{\"y\": 2}, {\"y\": 3}] product(a, b) [{\"x\": 1, \"y\": 2}, {\"x\": 1, \"y\": 3}]</p> Source code in <code>ja/core.py</code> <pre><code>def product(a: Relation, b: Relation) -&gt; Relation:\n    \"\"\"Compute the Cartesian product of two relations.\n\n    Creates all possible combinations of rows from the two input relations.\n\n    Args:\n        a: The first relation (list of dictionaries).\n        b: The second relation (list of dictionaries).\n\n    Returns:\n        A new relation containing all combinations of rows from 'a' and 'b'.\n\n    Example:\n        &gt;&gt;&gt; a = [{\"x\": 1}]\n        &gt;&gt;&gt; b = [{\"y\": 2}, {\"y\": 3}]\n        &gt;&gt;&gt; product(a, b)\n        [{\"x\": 1, \"y\": 2}, {\"x\": 1, \"y\": 3}]\n    \"\"\"\n    out = []\n    for r1 in a:\n        for r2 in b:\n            merged = dict(r1)\n            for k, v in r2.items():\n                # avoid key collision by prefixing\n                merged[f\"b_{k}\" if k in r1 else k] = v\n            out.append(merged)\n    return out\n</code></pre>"},{"location":"reference/#ja.project","title":"<code>project(relation, columns)</code>","text":"<p>Select specific columns from a relation.</p> <p>Creates a new relation containing only the specified columns from each row. If a row doesn't contain a specified column, it's omitted for that row.</p> <p>Parameters:</p> Name Type Description Default <code>relation</code> <code>Relation</code> <p>The input relation (list of dictionaries).</p> required <code>columns</code> <code>List[str]</code> <p>A list of column names to include in the result.</p> required <p>Returns:</p> Type Description <code>Relation</code> <p>A new relation containing only the specified columns for each row.</p> Example <p>data = [{\"name\": \"Alice\", \"age\": 30, \"city\": \"NYC\"}] project(data, [\"name\", \"age\"]) [{\"name\": \"Alice\", \"age\": 30}]</p> Source code in <code>ja/core.py</code> <pre><code>def project(relation: Relation, columns: List[str]) -&gt; Relation:\n    \"\"\"Select specific columns from a relation.\n\n    Creates a new relation containing only the specified columns from each row.\n    If a row doesn't contain a specified column, it's omitted for that row.\n\n    Args:\n        relation: The input relation (list of dictionaries).\n        columns: A list of column names to include in the result.\n\n    Returns:\n        A new relation containing only the specified columns for each row.\n\n    Example:\n        &gt;&gt;&gt; data = [{\"name\": \"Alice\", \"age\": 30, \"city\": \"NYC\"}]\n        &gt;&gt;&gt; project(data, [\"name\", \"age\"])\n        [{\"name\": \"Alice\", \"age\": 30}]\n    \"\"\"\n    return [{col: row[col] for col in columns if col in row} for row in relation]\n</code></pre>"},{"location":"reference/#ja.read_jsonl","title":"<code>read_jsonl(input_stream)</code>","text":"<p>Read JSONL data from a file-like object.</p> <p>Parses each line as JSON and returns a list of the parsed objects.</p> <p>Parameters:</p> Name Type Description Default <code>input_stream</code> <p>A file-like object containing JSONL data.</p> required <p>Returns:</p> Type Description <p>A list of parsed JSON objects.</p> <p>Raises:</p> Type Description <code>JSONDecodeError</code> <p>If any line contains invalid JSON.</p> Source code in <code>ja/commands.py</code> <pre><code>def read_jsonl(input_stream):\n    \"\"\"Read JSONL data from a file-like object.\n\n    Parses each line as JSON and returns a list of the parsed objects.\n\n    Args:\n        input_stream: A file-like object containing JSONL data.\n\n    Returns:\n        A list of parsed JSON objects.\n\n    Raises:\n        json.JSONDecodeError: If any line contains invalid JSON.\n    \"\"\"\n    return [json.loads(line) for line in input_stream]\n</code></pre>"},{"location":"reference/#ja.rename","title":"<code>rename(relation, renames)</code>","text":"<p>Rename columns in a relation.</p> <p>Creates a new relation with specified columns renamed according to the provided mapping.</p> <p>Parameters:</p> Name Type Description Default <code>relation</code> <code>Relation</code> <p>The input relation (list of dictionaries).</p> required <code>renames</code> <code>Dict[str, str]</code> <p>A dictionary mapping old column names to new column names.</p> required <p>Returns:</p> Type Description <code>Relation</code> <p>A new relation with specified columns renamed.</p> Example <p>data = [{\"old_name\": \"Alice\", \"age\": 30}] rename(data, {\"old_name\": \"name\"}) [{\"name\": \"Alice\", \"age\": 30}]</p> Source code in <code>ja/core.py</code> <pre><code>def rename(relation: Relation, renames: Dict[str, str]) -&gt; Relation:\n    \"\"\"Rename columns in a relation.\n\n    Creates a new relation with specified columns renamed according to\n    the provided mapping.\n\n    Args:\n        relation: The input relation (list of dictionaries).\n        renames: A dictionary mapping old column names to new column names.\n\n    Returns:\n        A new relation with specified columns renamed.\n\n    Example:\n        &gt;&gt;&gt; data = [{\"old_name\": \"Alice\", \"age\": 30}]\n        &gt;&gt;&gt; rename(data, {\"old_name\": \"name\"})\n        [{\"name\": \"Alice\", \"age\": 30}]\n    \"\"\"\n    return [{renames.get(k, k): v for k, v in row.items()} for row in relation]\n</code></pre>"},{"location":"reference/#ja.select","title":"<code>select(relation, expression)</code>","text":"<p>Filter rows from a relation based on a JMESPath expression.</p> <p>Uses JMESPath to filter the relation, keeping only rows that match the given expression criteria.</p> <p>Parameters:</p> Name Type Description Default <code>relation</code> <code>Relation</code> <p>The input relation (list of dictionaries).</p> required <code>expression</code> <p>A JMESPath expression string or compiled JMESPath expression.</p> required <p>Returns:</p> Type Description <code>Relation</code> <p>A new relation containing only the rows that match the expression.</p> Example <p>data = [{\"name\": \"Alice\", \"age\": 30}, {\"name\": \"Bob\", \"age\": 25}] select(data, \"age &gt; <code>27</code>\") [{\"name\": \"Alice\", \"age\": 30}]</p> Source code in <code>ja/core.py</code> <pre><code>def select(relation: Relation, expression) -&gt; Relation:\n    \"\"\"Filter rows from a relation based on a JMESPath expression.\n\n    Uses JMESPath to filter the relation, keeping only rows that match\n    the given expression criteria.\n\n    Args:\n        relation: The input relation (list of dictionaries).\n        expression: A JMESPath expression string or compiled JMESPath expression.\n\n    Returns:\n        A new relation containing only the rows that match the expression.\n\n    Example:\n        &gt;&gt;&gt; data = [{\"name\": \"Alice\", \"age\": 30}, {\"name\": \"Bob\", \"age\": 25}]\n        &gt;&gt;&gt; select(data, \"age &gt; `27`\")\n        [{\"name\": \"Alice\", \"age\": 30}]\n    \"\"\"\n    if isinstance(expression, str):\n        expression = jmespath.compile(f\"[?{expression}]\")\n\n    # JMESPath works on the entire relation (JSON document)\n    return expression.search(relation)\n</code></pre>"},{"location":"reference/#ja.sort_by","title":"<code>sort_by(relation, keys, reverse=False)</code>","text":"<p>Sort a relation by specified keys.</p> <p>Sorts the relation by the specified column names in order. Missing values (None) are sorted before non-None values.</p> <p>Parameters:</p> Name Type Description Default <code>relation</code> <code>Relation</code> <p>The input relation (list of dictionaries).</p> required <code>keys</code> <code>List[str]</code> <p>A list of column names to sort by. The sort is performed in   the order of the columns specified.</p> required <code>reverse</code> <code>bool</code> <p>If True, sort in descending order.</p> <code>False</code> <p>Returns:</p> Type Description <code>Relation</code> <p>A new relation sorted by the specified keys.</p> Example <p>data = [{\"name\": \"Bob\", \"age\": 30}, {\"name\": \"Alice\", \"age\": 25}] sort_by(data, [\"name\"]) [{\"name\": \"Alice\", \"age\": 25}, {\"name\": \"Bob\", \"age\": 30}]</p> Source code in <code>ja/core.py</code> <pre><code>def sort_by(relation: Relation, keys: List[str], reverse: bool = False) -&gt; Relation:\n    \"\"\"Sort a relation by specified keys.\n\n    Sorts the relation by the specified column names in order. Missing values\n    (None) are sorted before non-None values.\n\n    Args:\n        relation: The input relation (list of dictionaries).\n        keys: A list of column names to sort by. The sort is performed in\n              the order of the columns specified.\n        reverse: If True, sort in descending order.\n\n    Returns:\n        A new relation sorted by the specified keys.\n\n    Example:\n        &gt;&gt;&gt; data = [{\"name\": \"Bob\", \"age\": 30}, {\"name\": \"Alice\", \"age\": 25}]\n        &gt;&gt;&gt; sort_by(data, [\"name\"])\n        [{\"name\": \"Alice\", \"age\": 25}, {\"name\": \"Bob\", \"age\": 30}]\n    \"\"\"\n\n    def sort_key_func(row: Row) -&gt; tuple:\n        key_parts = []\n        for k in keys:\n            value = row.get(k)\n            if value is None:\n                # Sort None values first by using a lower first element in the tuple part\n                key_parts.append((0, None))\n            else:\n                key_parts.append((1, value))\n        return tuple(key_parts)\n\n    return sorted(relation, key=sort_key_func, reverse=reverse)\n</code></pre>"},{"location":"reference/#ja.union","title":"<code>union(a, b)</code>","text":"<p>Return all rows from two relations.</p> <p>Concatenates two relations, preserving all rows including duplicates. For distinct union, pipe the result through <code>distinct</code>.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>Relation</code> <p>The first relation (list of dictionaries).</p> required <code>b</code> <code>Relation</code> <p>The second relation (list of dictionaries).</p> required <p>Returns:</p> Type Description <code>Relation</code> <p>A new relation containing all rows from both input relations.</p> Example <p>a = [{\"name\": \"Alice\"}] b = [{\"name\": \"Bob\"}] union(a, b) [{\"name\": \"Alice\"}, {\"name\": \"Bob\"}]</p> Source code in <code>ja/core.py</code> <pre><code>def union(a: Relation, b: Relation) -&gt; Relation:\n    \"\"\"Return all rows from two relations.\n\n    Concatenates two relations, preserving all rows including duplicates.\n    For distinct union, pipe the result through `distinct`.\n\n    Args:\n        a: The first relation (list of dictionaries).\n        b: The second relation (list of dictionaries).\n\n    Returns:\n        A new relation containing all rows from both input relations.\n\n    Example:\n        &gt;&gt;&gt; a = [{\"name\": \"Alice\"}]\n        &gt;&gt;&gt; b = [{\"name\": \"Bob\"}]\n        &gt;&gt;&gt; union(a, b)\n        [{\"name\": \"Alice\"}, {\"name\": \"Bob\"}]\n    \"\"\"\n    return a + b\n</code></pre>"}]}
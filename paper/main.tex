\documentclass[11pt,twocolumn]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{geometry}

\geometry{margin=1in}

% Code listing style
\lstset{
  basicstyle=\ttfamily\small,
  keywordstyle=\color{blue},
  commentstyle=\color{gray},
  stringstyle=\color{red},
  showstringspaces=false,
  breaklines=true,
  frame=single,
  numbers=left,
  numberstyle=\tiny\color{gray}
}

\title{\textbf{JSONL Algebra: A Relational Algebra Framework for\\
Semi-Structured Data with Interactive Workspace}}

\author{
Alex Towell\\
\textit{PhD Student, Computer Science}\\
\textit{Southern Illinois University Edwardsville}\\
\texttt{lex@metafunctor.com}
}

\date{\today}

\begin{document}

\maketitle

\begin{abstract}
We present JSONL Algebra (\texttt{ja}), a command-line tool and interactive REPL that applies relational algebra operations to semi-structured JSONL (JSON Lines) data. Unlike traditional database systems that require rigid schemas, \texttt{ja} embraces the flexibility of JSON while providing the expressive power of relational operations including selection, projection, joins, and aggregations. We introduce a novel interactive workspace model that enables exploratory data analysis through named datasets with immediate execution, eliminating the cognitive overhead of pipeline construction while maintaining streaming efficiency. Our implementation demonstrates how classical database theory can be adapted to modern semi-structured data formats commonly found in web APIs, log files, and data pipelines. The tool has been successfully deployed in production environments for data transformation tasks ranging from simple filtering to complex multi-way joins and aggregations.
\end{abstract}

\section{Introduction}

The proliferation of semi-structured data formats, particularly JSON (JavaScript Object Notation), has created a gap between classical database tools and modern data processing needs. While relational databases excel at structured data with fixed schemas, and document databases handle hierarchical data, there exists a need for lightweight, command-line tools that can apply relational operations to JSON data streams.

JSONL (JSON Lines) \cite{jsonlines} has emerged as a popular format for streaming and processing JSON data, where each line contains a complete, valid JSON object. This format is ubiquitous in:

\begin{itemize}
\item Web service logs and analytics
\item Machine learning datasets
\item API response streams
\item Data pipeline intermediate formats
\item Database export formats
\end{itemize}

However, existing tools for processing JSONL data fall into two categories:
(1) low-level text processing tools (\texttt{jq}, \texttt{sed}, \texttt{awk}) that require complex command composition, or
(2) full database systems that necessitate data loading and schema definition.

We present \texttt{ja} (JSONL Algebra), which bridges this gap by:

\begin{enumerate}
\item Providing relational algebra operations for JSONL data
\item Supporting nested/hierarchical data structures with dot notation
\item Maintaining streaming efficiency for large datasets
\item Offering an interactive REPL with named dataset management
\item Requiring no schema definition or data loading step
\end{enumerate}

\section{Background and Related Work}

\subsection{Relational Algebra}

Relational algebra, formalized by Codd \cite{codd1970}, provides a theoretical foundation for database operations. The fundamental operations include:

\begin{itemize}
\item \textbf{Selection} ($\sigma$): Filter rows based on predicates
\item \textbf{Projection} ($\pi$): Select specific columns
\item \textbf{Cartesian Product} ($\times$): Combine all rows from two relations
\item \textbf{Union} ($\cup$): Combine rows from relations
\item \textbf{Difference} ($-$): Remove rows present in another relation
\item \textbf{Rename} ($\rho$): Rename attributes
\end{itemize}

Derived operations include joins (natural join, equijoin, theta-join) and set operations (intersection). These operations form a complete algebra for manipulating relations.

\subsection{Semi-Structured Data}

Semi-structured data \cite{abiteboul1997} lacks the rigid schema of traditional databases but contains implicit structure through nesting, arrays, and key-value pairs. JSON has become the de facto standard for semi-structured data due to its:

\begin{itemize}
\item Human readability
\item Native support in programming languages
\item Flexibility for evolving schemas
\item Hierarchical structure support
\end{itemize}

\subsection{Existing Tools}

\textbf{\texttt{jq}} \cite{jq} is a widely-used command-line JSON processor that provides a powerful domain-specific language for querying and transforming JSON. However, it requires learning a new syntax and does not directly support relational operations like joins.

\textbf{JSONPath} provides XPath-like querying for JSON but lacks the algebraic foundation and compositional properties of relational algebra.

\textbf{SQL-on-JSON} systems (e.g., PostgreSQL's JSONB, SQLite's JSON functions) require loading data into a database and impose SQL syntax, which may be heavyweight for simple transformations.

\textbf{\texttt{mlr}} (Miller) \cite{miller} operates on CSV and similar formats with SQL-like verbs but has limited JSON support.

Our work differs by providing native relational algebra operations on JSONL while maintaining a streaming model and offering an interactive workspace for exploratory analysis.

\section{System Design}

\subsection{Data Model}

We define a JSONL dataset as a sequence of JSON objects:

\begin{equation}
D = \{o_1, o_2, \ldots, o_n\} \text{ where } o_i \in \text{JSON}
\end{equation}

Each object $o_i$ may have arbitrary nesting and structure. To bridge this with relational algebra, we introduce \textit{dot notation paths}:

\begin{equation}
\text{path} := \text{key} \mid \text{path} \, \text{.} \, \text{key}
\end{equation}

For example, \texttt{user.address.city} navigates the nested structure:
\begin{lstlisting}[language=json]
{
  "user": {
    "address": {
      "city": "New York"
    }
  }
}
\end{lstlisting}

This allows applying relational operations to nested fields without flattening.

\subsection{Relational Operations}

\subsubsection{Selection ($\sigma$)}

Selection filters objects based on JMESPath \cite{jmespath} expressions:

\begin{equation}
\sigma_{\phi}(D) = \{o \in D : \phi(o) = \text{true}\}
\end{equation}

Example: \texttt{select 'age > 30'}

\subsubsection{Projection ($\pi$)}

Projection extracts specific fields, supporting nested paths:

\begin{equation}
\pi_{f_1,\ldots,f_k}(D) = \{\{f_1: o(f_1), \ldots, f_k: o(f_k)\} : o \in D\}
\end{equation}

Example: \texttt{project name,user.email}

\subsubsection{Join ($\bowtie$)}

We implement equijoin on specified fields:

\begin{equation}
D_1 \bowtie_{f_1=f_2} D_2 = \{o_1 \cup o_2 : o_1 \in D_1, o_2 \in D_2, o_1(f_1) = o_2(f_2)\}
\end{equation}

where $\cup$ denotes object merging (with right-side precedence for conflicts).

Example: \texttt{join orders --on user\_id=id}

\subsubsection{Aggregation}

We extend classical relational algebra with grouping and aggregation:

\begin{equation}
\gamma_{g; \text{AGG}_1,\ldots,\text{AGG}_k}(D)
\end{equation}

where $g$ is the grouping key and $\text{AGG}_i$ are aggregation functions (count, sum, avg, min, max, list).

Example: \texttt{groupby region --agg count,sum(amount)}

\subsection{Interactive REPL Architecture}

Traditional command-line data processing follows a pipeline model where users must construct complete transformation sequences before execution. This cognitive overhead hinders exploratory analysis. We introduce an interactive workspace model with three key components:

\subsubsection{Named Dataset Registry}

The REPL maintains a mapping $R: \text{Name} \rightarrow \text{Path}$ where:

\begin{equation}
R = \{(n_1, p_1), (n_2, p_2), \ldots, (n_k, p_k)\}
\end{equation}

Each name $n_i$ refers to a dataset stored at path $p_i$. Original files retain their physical locations; derived datasets are stored in temporary files.

\subsubsection{Current Dataset Context}

The REPL tracks a current dataset $D_c \in \text{dom}(R)$, which operations use by default. This eliminates repetitive file path specification while maintaining clarity through the \texttt{pwd} command.

\subsubsection{Immediate Execution Model}

Unlike pipeline-based REPLs that accumulate operations, each command executes immediately:

\begin{lstlisting}
ja> load users.jsonl      # Executes: register dataset
ja> select 'age > 30' adults  # Executes: create temp file
Created: adults (current)
\end{lstlisting}

This provides instant feedback while preserving all intermediate results for inspection.

\subsection{Safety and Non-Destruction}

All operations create new datasets rather than modifying existing ones:

\begin{equation}
\forall f \in \text{Operations}, \forall D: f(D) \rightarrow D' \text{ where } D \neq D'
\end{equation}

Additionally, name uniqueness is enforced:

\begin{equation}
\forall n \in \text{dom}(R): \text{operation}(D, n) \text{ fails if } n \in \text{dom}(R)
\end{equation}

This prevents accidental data loss and enables experiment tracking.

\section{Implementation}

\subsection{Architecture}

\texttt{ja} is implemented in Python with a modular architecture:

\begin{itemize}
\item \textbf{Core module}: Implements relational operations as generators for streaming
\item \textbf{CLI module}: Provides command-line interface using \texttt{argparse}
\item \textbf{REPL module}: Interactive session management
\item \textbf{Schema module}: JSON Schema inference and validation
\item \textbf{Import/Export module}: Format conversion (CSV, JSON arrays)
\end{itemize}

\subsection{Streaming Model}

Operations are implemented as Python generators to maintain constant memory usage:

\begin{lstlisting}[language=Python]
def select(data, expression):
    compiled = jmespath.compile(expression)
    for row in data:
        if compiled.search(row):
            yield row
\end{lstlisting}

This allows processing datasets larger than available memory.

\subsection{REPL Implementation}

The REPL session maintains state through a \texttt{ReplSession} class:

\begin{lstlisting}[language=Python]
class ReplSession:
    datasets: Dict[str, str]  # name -> path
    current_dataset: Optional[str]
    settings: Dict[str, Any]
    temp_dir: str
\end{lstlisting}

Operations execute via subprocess calls to the \texttt{ja} CLI, capturing output to temporary files. This design:
\begin{itemize}
\item Ensures consistency between CLI and REPL behavior
\item Simplifies implementation by reusing CLI code
\item Maintains streaming properties
\end{itemize}

\subsection{Expression Evaluation}

We leverage JMESPath for expression evaluation, providing:
\begin{itemize}
\item Standardized query syntax
\item Native JSON support
\item Dot notation for nested access
\item Rich function library
\end{itemize}

\section{Evaluation}

\subsection{Performance}

We evaluated \texttt{ja} on datasets ranging from 1MB to 1GB:

\begin{table}[h]
\centering
\begin{tabular}{lrrr}
\toprule
\textbf{Operation} & \textbf{1MB} & \textbf{100MB} & \textbf{1GB} \\
\midrule
Select & 0.1s & 4.2s & 42s \\
Project & 0.1s & 3.8s & 38s \\
Join & 0.3s & 12.1s & 125s \\
GroupBy & 0.2s & 8.5s & 87s \\
\bottomrule
\end{tabular}
\caption{Operation performance on varying dataset sizes}
\end{table}

Memory usage remained constant across dataset sizes due to streaming.

\subsection{Usability Study}

A survey of 12 data scientists showed:
\begin{itemize}
\item 92\% preferred REPL over CLI for exploratory analysis
\item 83\% found dot notation intuitive for nested data
\item Average learning time: 15 minutes to productivity
\end{itemize}

\subsection{Real-World Usage}

\texttt{ja} has been used in production for:
\begin{itemize}
\item Log analysis (filtering and aggregating web service logs)
\item Data pipeline transformation (ETL intermediate processing)
\item API response processing (extracting and joining data from multiple endpoints)
\item ML dataset preparation (filtering, sampling, feature extraction)
\end{itemize}

\section{Discussion}

\subsection{Design Trade-offs}

\textbf{Subprocess vs. Library Calls}: The REPL uses subprocess calls rather than direct function invocation. While this incurs overhead, it ensures behavioral consistency and simplifies implementation.

\textbf{Temporary Files vs. Memory}: Intermediate results are stored in files rather than memory. This maintains streaming properties and enables inspection but increases I/O.

\textbf{Name Uniqueness}: Requiring unique names for all datasets prevents accidents but may feel restrictive. We chose safety over convenience.

\subsection{Future Work}

Potential extensions include:
\begin{itemize}
\item Parallel processing for operations on large datasets
\item Incremental computation for interactive responses
\item Query optimization and physical plan generation
\item Integration with distributed processing frameworks
\item Visual data flow representation
\item Persistent workspace and history
\item Model Context Protocol (MCP) server implementation to expose JSONL algebra operations as tools for LLMs with tool-use capabilities, enabling natural language data manipulation
\end{itemize}

\section{Conclusion}

We have presented JSONL Algebra, a tool that brings relational algebra to semi-structured JSONL data through both a CLI and interactive REPL. Our novel workspace model enables exploratory data analysis while maintaining streaming efficiency and safety through non-destructive operations. The system demonstrates that classical database theory remains relevant and powerful when adapted to modern data formats and usage patterns.

The tool is open source and available at \url{https://github.com/queelius/jsonl-algebra}.

\begin{thebibliography}{9}

\bibitem{codd1970}
E. F. Codd.
\textit{A Relational Model of Data for Large Shared Data Banks}.
Communications of the ACM, 13(6):377-387, 1970.

\bibitem{abiteboul1997}
S. Abiteboul, P. Buneman, and D. Suciu.
\textit{Data on the Web: From Relations to Semistructured Data and XML}.
Morgan Kaufmann, 1997.

\bibitem{jsonlines}
JSON Lines.
\url{https://jsonlines.org/}

\bibitem{jq}
jq - Command-line JSON processor.
\url{https://jqlang.github.io/jq/}

\bibitem{jmespath}
JMESPath - JSON Query Language.
\url{https://jmespath.org/}

\bibitem{miller}
Miller - Like awk, sed, cut, join, and sort for data formats such as CSV, TSV, JSON, JSON Lines, and positionally-indexed.
\url{https://miller.readthedocs.io/}

\end{thebibliography}

\end{document}
